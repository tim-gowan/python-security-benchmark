"""
SCA Reachability Test: django-cachalot library (CVE-2022-28347)

This file demonstrates REACHABLE code that calls vulnerable functions in django-cachalot
and its transitive dependency Django.

Call Path:
1. First-party code: main() → Django view → get_tables_view() → cachalot.utils._get_tables()
2. Direct dependency: cachalot.utils._get_tables() → Django ORM calls
3. Transitive dependency: django.db.models.sql.compiler.SQLCompiler.as_sql() (vulnerable)
4. Transitive dependency: django.db.backends.postgresql.operations.DatabaseOperations.explain_query_prefix()

CVE-2022-28347: SQL injection vulnerability in Django's SQLCompiler.as_sql() when used
with django-cachalot's _get_tables() function.

Exploit Scenario:
- Attacker controls input to Django view
- View calls cachalot.utils._get_tables() which generates SQL queries
- Vulnerable SQLCompiler.as_sql() processes the query, potentially allowing SQL injection
- This demonstrates inversion of control in Django framework (request → view → ORM)

Note: Django uses inversion of control - code is reachable through HTTP requests to views.
"""

import os
import sys
import django
from django.conf import settings
from django.core.wsgi import get_wsgi_application
from django.http import JsonResponse
from django.urls import path
from django.views import View

# Minimal Django settings configuration
if not settings.configured:
    settings.configure(
        DEBUG=True,
        SECRET_KEY='benchmark-test-key-not-for-production',
        ROOT_URLCONF=__name__,
        INSTALLED_APPS=[
            'django.contrib.contenttypes',
            'django.contrib.auth',
            'cachalot',
        ],
        DATABASES={
            'default': {
                'ENGINE': 'django.db.backends.sqlite3',
                'NAME': ':memory:',
            }
        },
        CACHALOT_ENABLED=True,
    )


class GetTablesView(View):
    """
    Django view that calls cachalot.utils._get_tables().
    
    This view is reachable through HTTP requests (Django's inversion of control).
    The call path demonstrates reachability through framework routing.
    
    Call path:
    - HTTP request → Django URL routing → this view
    - View.get() → cachalot.utils._get_tables() (direct dependency)
    - _get_tables() → Django ORM → SQLCompiler.as_sql() (transitive - vulnerable)
    """
    
    def get(self, request):
        """
        Handle GET request and call vulnerable cachalot function.
        
        This method is called by Django framework when URL is accessed.
        Demonstrates inversion of control - code is reachable via HTTP requests.
        
        Args:
            request: Django HttpRequest object (may contain attacker-controlled data)
        
        Returns:
            JsonResponse with table information
        """
        try:
            # Import here to ensure Django is configured
            from cachalot import utils as cachalot_utils
            
            # Direct call to vulnerable function in direct dependency
            # This transitively calls Django's SQLCompiler.as_sql() (CVE-2022-28347)
            # Call path: _get_tables() → Django ORM → SQLCompiler.as_sql() → DatabaseOperations
            tables = cachalot_utils._get_tables()
            
            # Payload: Attacker-controlled request parameters could influence SQL generation
            # The vulnerable SQLCompiler.as_sql() processes queries generated by cachalot
            
            return JsonResponse({
                'tables': list(tables) if tables else [],
                'status': 'success'
            })
        except Exception as e:
            return JsonResponse({
                'error': str(e),
                'status': 'error'
            }, status=500)


def get_tables_direct():
    """
    Direct function call (not through Django view) for testing.
    
    This demonstrates the same vulnerable call path but without HTTP request.
    Useful for direct execution testing.
    
    Call path:
    - Direct call → cachalot.utils._get_tables()
    - _get_tables() → Django ORM → SQLCompiler.as_sql() (vulnerable)
    """
    from cachalot import utils as cachalot_utils
    
    # Direct call to vulnerable function
    # Transitive path: _get_tables() → SQLCompiler.as_sql() (CVE-2022-28347)
    tables = cachalot_utils._get_tables()
    return tables


# Django URL configuration
urlpatterns = [
    path('api/tables', GetTablesView.as_view(), name='get_tables'),
]


# WSGI application for Django server
application = get_wsgi_application()


if __name__ == "__main__":
    """
    Entry point for Django application.
    
    This demonstrates two execution modes:
    1. Direct execution: Calls get_tables_direct() (bypasses HTTP)
    2. View instantiation: Shows how GetTablesView.get() would be called via HTTP
    
    For reachability testing, both paths should be considered:
    - Direct call path: main() → get_tables_direct() → _get_tables() → SQLCompiler
    - HTTP call path: HTTP request → GetTablesView.get() → _get_tables() → SQLCompiler
    
    Note: Django uses inversion of control - views are reachable through HTTP requests.
    To test the HTTP path, you would:
    1. Start Django server: python manage.py runserver
    2. Make HTTP request to: http://localhost:8000/api/tables
    3. Django routes request → GetTablesView.get() → cachalot → SQLCompiler (vulnerable)
    """
    
    # Initialize Django
    django.setup()
    
    # Mode 1: Direct function call (simpler for testing)
    # This directly calls the vulnerable function chain
    # Call path: get_tables_direct() → cachalot.utils._get_tables() → SQLCompiler.as_sql()
    print("Testing direct call path...")
    print("Call path: main() → get_tables_direct() → cachalot._get_tables() → SQLCompiler.as_sql()")
    try:
        tables = get_tables_direct()
        print(f"Direct call successful. Tables: {tables}")
    except Exception as e:
        print(f"Direct call error (expected if DB not configured): {e}")
        print("Note: The vulnerable code path is still reachable even if execution fails")
    
    # Mode 2: Demonstrate view instantiation (shows HTTP path)
    # In a real Django app, this view would be called via HTTP request
    # Call path: HTTP request → URL routing → GetTablesView.get() → cachalot → SQLCompiler
    print("\nDemonstrating Django view path (inversion of control)...")
    print("In production, this view would be reached via HTTP request to /api/tables")
    print("Call path: HTTP request → GetTablesView.get() → cachalot._get_tables() → SQLCompiler.as_sql()")
    
    # Create a mock request object to demonstrate the view call
    from django.test import RequestFactory
    factory = RequestFactory()
    request = factory.get('/api/tables')
    
    # Instantiate and call the view (simulates HTTP request)
    # This demonstrates that the view is reachable through Django's routing
    view = GetTablesView.as_view()
    try:
        response = view(request)
        print(f"View call successful. Response status: {response.status_code}")
    except Exception as e:
        print(f"View call error (expected if DB not configured): {e}")
        print("Note: The vulnerable code path in GetTablesView.get() is still reachable")
    
    print("\nBoth execution paths demonstrate reachability to vulnerable SQLCompiler.as_sql()")

